"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var raygun_transport_1 = require("./raygun.transport");
var timer_1 = require("./timer");
var types_1 = require("./types");
var debug = require("debug")("raygun");
exports.MAX_MESSAGES_IN_BATCH = 100;
exports.MAX_BATCH_SIZE_BYTES = 1638400;
var MAX_BATCH_INNER_SIZE_BYTES = exports.MAX_BATCH_SIZE_BYTES - 2; // for the starting and ending byte
var RaygunBatchTransport = /** @class */ (function () {
    function RaygunBatchTransport(options) {
        this.messageQueue = [];
        this.intervalId = null;
        this.batchId = 0;
        this.interval = options.interval;
        this.httpOptions = options.httpOptions;
    }
    RaygunBatchTransport.prototype.send = function (options) {
        this.messageQueue.push({
            serializedMessage: options.message,
            callback: options.callback,
        });
    };
    RaygunBatchTransport.prototype.startProcessing = function () {
        debug("batch transport - starting message processor (frequency=" + this.interval + ")");
        this.intervalId = setInterval(this.process.bind(this), this.interval);
    };
    RaygunBatchTransport.prototype.stopProcessing = function () {
        if (this.intervalId) {
            debug("batch transport - stopping");
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    };
    RaygunBatchTransport.prototype.process = function () {
        debug("batch transport - processing (" + this.messageQueue.length + " message(s) in queue)");
        var _a = prepareBatch(this.messageQueue), payload = _a.payload, messageCount = _a.messageCount, callbacks = _a.callbacks;
        if (messageCount === 0) {
            return;
        }
        var batchId = this.batchId;
        this.batchId++;
        var runAllCallbacks = function (err, response) {
            var durationInMs = stopTimer();
            if (err) {
                debug("batch transport - error sending batch (id=" + batchId + ", duration=" + durationInMs + "ms): " + err);
            }
            else {
                debug("batch transport - successfully sent batch (id=" + batchId + ", duration=" + durationInMs + "ms)");
            }
            for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                var callback = callbacks_1[_i];
                types_1.callVariadicCallback(callback, err, response);
            }
        };
        debug("batch transport - sending batch (id=" + batchId + ") (" + messageCount + " messages, " + payload.length + " bytes)");
        var stopTimer = timer_1.startTimer();
        raygun_transport_1.sendBatch({
            message: payload,
            callback: runAllCallbacks,
            http: this.httpOptions,
        });
    };
    return RaygunBatchTransport;
}());
exports.RaygunBatchTransport = RaygunBatchTransport;
function prepareBatch(messageQueue) {
    var batch = [];
    var callbacks = [];
    var batchSizeBytes = 0;
    for (var i = 0; i < exports.MAX_MESSAGES_IN_BATCH; i++) {
        if (messageQueue.length === 0) {
            break;
        }
        var _a = messageQueue[0], serializedMessage = _a.serializedMessage, callback = _a.callback;
        if (batchSizeBytes + serializedMessage.length >
            MAX_BATCH_INNER_SIZE_BYTES) {
            break;
        }
        batch.push(serializedMessage);
        if (callback) {
            callbacks.push(callback);
        }
        if (i === 0) {
            batchSizeBytes += serializedMessage.length;
        }
        else {
            batchSizeBytes += serializedMessage.length + 1; // to account for the commas between items
        }
        messageQueue.shift();
    }
    return {
        payload: "[" + batch.join(",") + "]",
        messageCount: batch.length,
        callbacks: callbacks,
    };
}
exports.prepareBatch = prepareBatch;
